# 절차 지향 프로그래밍(Procedural Programming)
- 프로그램을 함수와 로직(절차) 중심으로 작성. 
- 데이터를 함수에 전달하며 순차적으로 처리.
- 변수와 함수를 별개로 다룸

## 절차 지향 프로그래밍 특징

- 입력을 받고, 처리하고, 결과를 내는 과정이 위에서 아래로 순차적으로 흐르는 형태
- 순차적인 명령어 실행
- 데이터와 함수(절차)의 분리
- 함수 호출의 흐름이 중요

-> 요리 레시피를 차례대로 따라가는 것과 비슷, 레시피 순서를 하나씩 밟아 나가는 형식

## 절차 지향적 프로그래밍의 한계
1. 복잡성 증가
    - 프로그램 규모가 커질수록 데이터와 함수의 관리가 어려움.
    - 전역 변수의 증가로 인한 관리의 어려움

2. 유지보수 문제
     - 코드 수정 시 영향 범위 파악이 어려움

# 객체 지향 프로그래밍 (Object Oriented Programming)
- 데이터와 함수를 하나의 단위(객체)로 묶어서 관리.
- 객체들을 조합하고 재활용하는 방식으로 프로그램 구성

## 객체 지향 프로그래밍 특징

- 프로그램을 데이터(변수)와 그 데이터를 처리하는 함수(메서드)를 하나의 단위(객체)로 묶어서 조직적으로 관리
- 데이터와 메서드의 결합

-> 주방 도구(프라이팬, 칼), 재료(야채, 고기), 행동(볶기, 썰기)를 각각 별개로 생각하지 않고, "볶음밥 기계"라는 객체로 만들어 놓고 그 기계가 알아서 해당 행동과 재료를 관리하는 방식.

절차 지향과 객체 지향은 대조되는 개념이 이나다.

plus 알파의 개념.

class 객체를 만들기 위한 설계도

## 클래스 정의하는 방법.

클래스 이름은 파스칼 케이스(Pascal Case)방식으로 작성
(지금까지 변수는 보통 snake_case 방식으로 작성)

- __init__ 메서드는 '생성자 메서드로 불리며, 새로운 객체를 만들 때 필요한 초기값을 설정 (메서드 챕터에서 진행) -> 개발자가 실제로 호출 진행 x
- *init: 초기화

### 인스턴스

- **클래스**를 통해 생성된 객체

- 인스턴스 예시

    - 클래스가 설계도라면, 인스턴스는 그 설계도로부터 실제로 만든 '개별 물건'
    - Person("Alice", 25)라고 하면 Person이라는 설계도로부터 이름이 Alice이고 나이가 25인 '사람 객체'가 탄생

- 클래스와 인스턴스

    가수(클래스) -> 
                    
                   아이유는 객체다. (o)

                   아이유는 인스턴스다. (x)

                   아이유는 가수의 인스턴스다. (o)

---

# OOP2

## 상속(Inheritance)
- 한 클래스(부모)의 속성과 메서드를 다른 클래스(자식)가 물려받는 것

### 상속이 필요한 이유
1. 코드 재사용
- 상속을 통해 기존 클래스의 속성과 메서드를 재사용할 수 있음
- 기존 클래스를 수정하지 않고도 기능을 확장할 수 있음

2. 계층 구조
- 상속을 통해 클래스들 간의 계층 구조를 형성할 수 있음
- 부모 클래스와 자식 클래스 간의 관계를 표현하고, 더 구체적인 클래스를 만들 수 있음

3. 유지 보수의 용이성
- 상속을 통해 기존 클래스의 수정이 필요한 경우, 해당 클래스만 수정하면 되므로 유지 보수가 용이해짐.
- 코드의 일관성을 유지하고, 수정이 필요한 범위를 최소화할 수 있음.

### 클래스 예시

```
class Animal:
    def eat(self):
        print('먹는 중')


class Dog(Animal): - 상속의 기본적인 형태
    def bark(self):
        print('멍멍')


my_dog = Dog()

my_dog.bark()  #

# 부모 클래스(Animal) 메서드 사용 가능

```
### 메서드 오버라이딩(Method Overrining)
- 부모 클래스의 메서드를 같은 이름, 같은 파라미터 구조로 재정의하는 것

```
메서드 오버라이딩 예시
- 자식 클래스가 부모 클래스의 메서드를 덮어써서 새로운 동작을 구현할 수 있음

class Animal:
    def eat(self):
        print('Animal이 먹는 중')


class Dog(Animal):
    # 오버라이딩 (부모 클래스 Animal의 eat 메서드를 재정의)
    def eat(self):
        print('Dog가 먹는 중')


my_dog = Dog()

my_dog.eat()  # Dog가 먹는 중
```

- [참고] 오버로딩(Overloading)

    - 같은 이름, 다른 파라미터를 가진 여러 메서드를 정의하는 것(파이썬은 미지원)
    - 파이썬은 실제로 하나의 메서드만 인식하며, 인자의 형태가 다르다는 이유로 메서드를 여러 개 구분하여 불러주지 않음


### 다중 상속
- 둘 이상의 상위 클래스로부터 여러 행동이나 특징을 상속받을 수 있는 것
- 상속받은 모든 클래스의 요소를 활용 가능함
- 중복된 속성이나 메서드가 있는 경우 **상속 순서에 의해 결정**됨.

### 다이아몬드 문제(The diamond problem)
- 두 클래스 B와 C가 A에서 상속되고 클래스 D가 B와 C 모두에서 상속될 때 발생하는 모호함
- B와 C가 재정의한 메서드가 A에 있고 D가 이를 재정의하지 않은 경우라면

    -> D는 B의 메서드 중 어떤 버전을 상속하는가?

    아니면 C의 메서드 버전을 상속하는가?

### 파이썬에서의 해결책
- MRO(Method Resolution Order) 알고리즘을 사용하여 클래스 목록을 생성
- 부모 클래스로부터 상속된 속성들의 검색을 깊이 우선으로, 왼쪽에서 오른쪽으로, 계층 구조에서 겹치는 같은 클래스를 두 번 검색하지 않음.
- 그래서, 속성이 D에서 발견되지 않으면, B에서 찾고, 거기에서도 발견되지 않으면, C에서 찾고, 이런 식으로 진행됨.

### MRO(Method Resolution Order)
- 파이썬이 메서드를 찾는 순서에 대한 규칙.
- 메서드 결정 순서


## super()
- 부모 클래스(또는 상위 클래스)의 메서드를 호출하기 위해 사용하는 내장 함수.

### super()의 기능
- 다중 상속 상황에서 특히 유용하며, MRO를 따르기 떄문에 여러 부모 클래스를 가진 자식 클래스에서 다음에 호출해야 할 부모 메서드를 순서대로 호출할 수 있게 함

### super의 2가지 사용 사례
1. 단일 상속 구조 
- 명시적으로 이름을 지정하지 않고 부모 클래스를 참조할 수 있으므로, 코드를 더 유지 관리하기 쉽게 만들 수 있음
- 클래스 이름이 변경되거나 부모 클래스가 교체되어도 super()를 사용하면 코드 수정이 더 적게 필요.
2. 다중 상속 구조
- MRO를 따른 메서드 호출
- 복잡한 다중 상속 구조에서 발생할 수 있는 문제를 방지

### super()의 이점
- 다중 상속 상황에서 super()는 다음에 호출해야 할 부모 메서드를 MRO 순서에 따라 결정하기 때문에, 명시적으로 특정 부모 클래스를 가리키지 않고도 올바른 순서로 부모 초기화나 메서드 호출이 가능
- 이를 통해 복잡한 상속 구조에서도 코드를 유연하고 깔끔하게 유지할 수 있음

### super() 정리
- super()를 사용할 때는 MRO를 잘 이해하고 있어야 함.
- ClassName. __ _mro_ __ 또는 ClassName.mro()를 확인해 MRO 순서를 파악한 뒤 적절히 활용하는 연습을 하면, 보다 복잡한 상속 구조에서도 코드를 잘 관리할 수 있음.

### MRO가 필요한 이유

- 부모 클래스들이 여러 번 액세스 되지 않도록, 각 클래스에서 지정된 왼쪽에서 오른쪽으로 가는 순서를 보존하고, 각 부모를 오직 한 번만 호출하고, 부모들의 우선순위에 영향을 주지 않으면서 서브 클래스를 만드는 단조적인 구조 형성

-> 프로그래밍 언어의 신뢰성 있고 확정성 있는 클래스를 설계할 수 있도록 도움

-> 클래스 간의 메서드 호출 순서가 예측 가능하게 유지되며, 코드의 재사용성과 유지보수성이 향상

## 참고

### 왜 클래스를 배웠을까?

- 지금까지 우리는 변수와 함수만으로도 간단한 프로그램을 만들 수 있었습니다.
- 그러나 프로그램 규모가 커지면 서로 관련 있는 정보와 기능을 따로따로 관리하기가 점점 어려워집니다.
- 클래스를 사용하면 관련된 데이터와 기능을 '한 덩어리'로 묶어 구조를 명확히 할 수 있습니다.
- 이로써 작성한 코드가 훨씬 깔끔해지고, 나중에 수정하거나 기능을 추가할 때 더 쉽고 안전해집니다.

### 실제 개발 상황 속 클래스
- 예시: 도서 관리 프로그램
    - 책을 나타내는 클래스를 만들고(title, author, price 같은 속성과 print_info()같은 기능), 이 클래스를 이용해 여러 권의 책 객체를 다룰 수 있음.
    - 이렇게 하면 책 관련 코드와 로직이 한 곳에 모여 있어, 재사용과 관리가 편해짐.

### 알고리즘 문제풀이와 OOP